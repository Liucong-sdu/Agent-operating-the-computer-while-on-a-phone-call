# Voice Agent + Computer Tool 项目开发文档

## 项目概述

本项目旨在创建一个智能语音助手，能够通过自然语言与用户交互，并根据用户指令自动操作网页界面。项目结合了语音交互技术(voice_agent)和计算机自动化操作工具(computer_tool)，为用户提供便捷的网页操作体验。

## 技术架构

```
用户语音输入 → Voice Agent → LLM处理 → Computer Tool Agent → 网页操作
     ↑                                                        ↓
   语音反馈 ← LLM响应生成 ← 操作结果反馈 ← 网页操作执行结果
```

### 核心组件

1. **Voice Agent**: 负责语音输入/输出处理
2. **LLM对话系统**: 理解用户意图，生成操作指令
3. **Computer Tool Agent**: 执行具体的网页操作
4. **测试网页**: 提供操作目标页面

## 功能模块设计

### 1. 网页自动启动模块
- **功能**: 程序启动时自动打开指定测试网址
- **实现方式**: 使用Python的`webbrowser`模块或`selenium`
- **配置**: 可配置的测试网址
```python
# 示例配置
TEST_URL = "https://example-test-site.com"
```

### 2. LLM交互模块
- **功能**: 与用户进行自然语言对话
- **技术选型**: 
  - OpenAI GPT API
  - 或本地部署的开源模型(如Llama2, ChatGLM等)
- **核心功能**:
  - 理解用户指令
  - 生成操作命令
  - 提供操作反馈

### 3. Computer Tool Agent模块（基于Browser-Use框架）
用户负责的核心部分，采用[Browser-Use](https://github.com/browser-use/browser-use)开源框架实现：

#### 3.1 Browser-Use框架优势
- **AI原生设计**: 专为AI代理操控浏览器而设计
- **自然语言驱动**: 直接接受自然语言指令，无需复杂的元素定位
- **智能操作**: 自动识别页面元素，执行复杂的网页操作
- **高度兼容**: 支持各种现代网站和复杂UI交互
- **66.6k+ Stars**: 成熟稳定的开源项目

#### 3.2 核心功能实现
```python
import asyncio
from browser_use import Agent
from browser_use.llm import ChatOpenAI

class ComputerToolAgent:
    def __init__(self, llm_model="gpt-4o-mini"):
        self.llm = ChatOpenAI(model=llm_model, temperature=0.7)
    
    async def execute_task(self, task_description, target_url=None):
        """执行用户指令的核心方法"""
        if target_url:
            task_with_url = f"先打开网址 {target_url}，然后{task_description}"
        else:
            task_with_url = task_description
            
        agent = Agent(
            task=task_with_url,
            llm=self.llm,
        )
        result = await agent.run()
        return result
```

#### 3.3 支持的操作类型
- **导航操作**: 打开网页、点击链接、前进后退
- **表单操作**: 填写输入框、选择下拉菜单、提交表单
- **交互操作**: 点击按钮、选择选项、拖拽元素
- **信息提取**: 读取页面内容、提取数据、截图保存
- **复杂任务**: 多步骤工作流、条件判断、循环操作

#### 3.4 与LLM的无缝集成
Browser-Use框架天然支持与各种LLM的集成：
- OpenAI GPT系列
- Anthropic Claude
- Google Gemini
- 本地开源模型

### 4. 指令处理流程
```python
async def process_user_command(user_input: str, test_url: str = None):
    """处理用户自然语言指令"""
    
    # 1. 创建Agent实例
    agent = ComputerToolAgent()
    
    # 2. 执行任务
    try:
        result = await agent.execute_task(user_input, test_url)
        return {
            "success": True,
            "message": "任务执行成功",
            "result": result
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"任务执行失败: {str(e)}"
        }
```

## 项目结构

```
computer_tool/
├── main.py                 # 主程序入口
├── .env                    # 环境变量配置（API Keys等）
├── config/
│   ├── __init__.py
│   └── settings.py         # 配置文件
├── voice_agent/
│   ├── __init__.py
│   ├── speech_recognition.py  # 语音识别
│   └── text_to_speech.py      # 语音合成
├── llm_module/
│   ├── __init__.py
│   ├── chat_handler.py     # LLM对话处理
│   └── response_processor.py  # 响应处理
├── computer_tool/          # 用户负责的核心模块（基于Browser-Use）
│   ├── __init__.py
│   ├── browser_agent.py    # Browser-Use代理封装
│   ├── task_executor.py    # 任务执行器
│   ├── web_launcher.py     # 网页启动器
│   └── utils.py            # 工具函数
├── tests/
│   ├── __init__.py
│   ├── test_browser_operations.py  # Browser-Use功能测试
│   └── test_integration.py         # 集成测试
├── examples/
│   ├── demo_tasks.py       # 示例任务
│   └── test_websites/      # 测试网站
├── requirements.txt        # 依赖包列表
└── README.md              # 项目说明
```

## 技术栈

### 必需依赖
- **Python 3.11+**: 主要开发语言（Browser-Use要求）
- **browser-use**: 核心浏览器自动化框架
- **playwright**: 浏览器驱动（Browser-Use依赖）
- **OpenAI API** / **Anthropic Claude** / **其他LLM API**: LLM集成
- **speech_recognition**: 语音识别
- **pyttsx3**: 文字转语音
- **asyncio**: 异步编程支持

### Browser-Use支持的LLM
- OpenAI GPT系列 (gpt-4o, gpt-4o-mini等)
- Anthropic Claude系列
- Google Gemini
- DeepSeek-V3
- Azure OpenAI
- 本地开源模型

### 可选依赖
- **PyQt5/tkinter**: GUI界面（如需要）
- **logging**: 日志记录
- **pytest**: 单元测试
- **python-dotenv**: 环境变量管理

## 开发计划

### 第一阶段：基础环境搭建
1. **项目环境配置**
   - 创建Python 3.11+虚拟环境
   - 安装browser-use框架和依赖
   - 配置playwright浏览器
   ```bash
   pip install browser-use
   playwright install chromium --with-deps --no-shell
   ```

2. **环境变量配置**
   - 创建.env文件
   - 配置LLM API密钥
   - 设置测试网址参数

### 第二阶段：Computer Tool核心功能开发（用户负责部分）
1. **Browser-Use代理封装**
   - 创建ComputerToolAgent类
   - 实现任务执行接口
   - 配置LLM模型连接

2. **网页启动器开发**
   - 自动打开测试网址功能
   - 浏览器会话管理
   - 页面状态监控

3. **任务执行器开发**
   - 自然语言指令处理
   - 操作结果收集和反馈
   - 错误处理和重试机制

4. **基础功能测试**
   - 简单网页操作测试
   - 复杂任务流程验证

### 第三阶段：LLM对话系统集成
1. **对话处理器开发**
   - 用户输入理解
   - 上下文管理
   - 任务分解和规划

2. **响应生成系统**
   - 操作结果解读
   - 用户友好的反馈生成
   - 多轮对话支持

### 第四阶段：Voice Agent集成
1. **语音识别模块**
   - 实时语音输入处理
   - 语音到文本转换
   - 噪音过滤和优化

2. **语音合成模块**
   - 文本到语音转换
   - 自然语音输出
   - 多语言支持（可选）

### 第五阶段：系统集成和优化
1. **完整流程集成**
   - 语音→LLM→Browser-Use完整链路
   - 实时反馈和状态更新
   - 异常处理和恢复

2. **性能优化和测试**
   - 响应速度优化
   - 稳定性测试
   - 用户体验改善

## Browser-Use框架快速入门

### 安装和配置
```bash
# 安装browser-use
pip install browser-use

# 安装浏览器（必需）
playwright install chromium --with-deps --no-shell

# 安装CLI工具（可选）
pip install "browser-use[cli]"
```

### 环境变量配置 (.env文件)
```bash
# OpenAI API Key
OPENAI_API_KEY=sk-your-openai-api-key

# 或者使用其他LLM
ANTHROPIC_API_KEY=your-anthropic-key
GOOGLE_API_KEY=your-google-key
DEEPSEEK_API_KEY=your-deepseek-key
```

### 基础使用示例
```python
import asyncio
from dotenv import load_dotenv
from browser_use import Agent
from browser_use.llm import ChatOpenAI

# 加载环境变量
load_dotenv()

async def example_web_automation():
    # 创建AI代理
    agent = Agent(
        task="打开百度搜索，搜索'Python教程'，点击第一个结果",
        llm=ChatOpenAI(model="gpt-4o-mini", temperature=0.7),
    )
    
    # 执行任务
    result = await agent.run()
    return result

# 运行示例
if __name__ == "__main__":
    asyncio.run(example_web_automation())
```

### 项目中的使用示例
```python
# computer_tool/browser_agent.py
import asyncio
from browser_use import Agent
from browser_use.llm import ChatOpenAI

class WebAutomationAgent:
    def __init__(self, api_key: str, model: str = "gpt-4o-mini"):
        self.llm = ChatOpenAI(
            api_key=api_key,
            model=model,
            temperature=0.7
        )
    
    async def execute_web_task(self, task_description: str, target_url: str = None):
        """执行网页自动化任务"""
        
        # 如果指定了目标网址，将其包含在任务中
        if target_url:
            full_task = f"首先打开网址: {target_url}，然后{task_description}"
        else:
            full_task = task_description
        
        # 创建代理并执行任务
        agent = Agent(
            task=full_task,
            llm=self.llm,
        )
        
        try:
            result = await agent.run()
            return {
                "success": True,
                "result": result,
                "message": "任务执行成功"
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "message": "任务执行失败"
            }

# 使用示例
async def main():
    agent = WebAutomationAgent(api_key="your-api-key")
    
    # 示例任务1：表单填写
    result1 = await agent.execute_web_task(
        "填写登录表单，用户名填写'testuser'，密码填写'password123'",
        "https://example-login-site.com"
    )
    
    # 示例任务2：信息提取
    result2 = await agent.execute_web_task(
        "找到页面上的价格信息并记录下来",
        "https://example-product-page.com"
    )
    
    print("任务1结果:", result1)
    print("任务2结果:", result2)

if __name__ == "__main__":
    asyncio.run(main())
```

### Browser-Use的强大功能演示
基于[Browser-Use GitHub](https://github.com/browser-use/browser-use)的示例，该框架可以处理复杂的任务：

1. **电商购物**: "添加商品到购物车并结账"
2. **数据收集**: "从LinkedIn找到最新关注者并保存到Salesforce"
3. **文档处理**: "在Google文档中写一封感谢信并保存为PDF"
4. **求职申请**: "查找ML相关工作并自动申请"
5. **信息搜索**: "在Hugging Face上找到CC-BY-SA-4.0许可的热门模型"

这些复杂任务都可以通过简单的自然语言指令完成！

## 重要注意事项

### 安全性考虑
- 限制操作范围在测试网站
- 实现操作权限控制
- 添加操作确认机制

### 稳定性设计
- 网络连接异常处理
- 页面加载超时处理
- 元素定位失败重试

### 扩展性考虑
- 支持多种浏览器
- 可配置的操作策略
- 插件化架构设计

## 开发问题讨论

在使用Browser-Use框架的开发过程中，以下问题需要进一步确认：

### 核心技术选择

1. **测试网址选择**: 您希望使用哪个具体的测试网站？推荐选择：
   - 简单表单网站（如登录页面）
   - 电商演示网站（如购物流程）
   - 或者自定义的测试页面

2. **LLM模型选择**: Browser-Use支持多种LLM，建议：
   - **OpenAI GPT-4o-mini**: 性价比高，响应快速
   - **Claude-3.5-Sonnet**: 理解能力强，适合复杂任务
   - **GPT-4o**: 最强性能，适合复杂网页操作
   - 您更倾向于使用哪个模型？

3. **语音交互设计**:
   - 实时语音识别 vs 按键激活（推荐按键激活，更稳定）
   - 语音反馈的详细程度
   - 是否需要支持多语言？

### Browser-Use特定配置

4. **浏览器配置**:
   - 是否需要无头模式（headless）运行？
   - 是否显示浏览器操作过程给用户观看？
   - 浏览器窗口大小和位置设置

5. **任务复杂度控制**:
   - 单步简单任务 vs 多步复杂工作流
   - 是否需要任务中断和恢复功能？
   - 错误处理策略（重试次数、失败反馈等）

6. **用户界面设计**:
   - 命令行界面 vs 图形界面
   - 实时操作状态显示
   - 操作历史记录查看

### 集成和部署

7. **Voice Agent集成方式**:
   - 如何将语音输入转换为Browser-Use任务？
   - 语音和浏览器操作的同步处理
   - 多模态反馈（语音+视觉）

8. **部署和运行环境**:
   - 本地开发环境 vs 生产环境
   - Docker容器化部署
   - 云端部署考虑（如果需要）

### 性能和安全

9. **性能优化**:
   - 并发任务处理能力
   - 内存和CPU使用优化
   - 网络延迟处理

10. **安全和限制**:
    - 操作权限控制
    - 敏感信息保护
    - 恶意指令防护

请您就这些问题提供意见，特别是：
- **LLM模型偏好**
- **测试网站类型**
- **用户界面需求**
- **部署方式偏好**

这样我可以为您制定更精确的技术实现方案。

---

## 总结

采用[Browser-Use](https://github.com/browser-use/browser-use)框架将极大简化项目开发：

✅ **开发效率提升**: 无需复杂的元素定位和WebDriver配置  
✅ **自然语言驱动**: 直接使用自然语言描述任务  
✅ **强大的AI能力**: 66.6k+ Stars的成熟框架  
✅ **丰富的示例**: 从简单操作到复杂工作流  
✅ **多LLM支持**: 灵活选择最适合的AI模型  

该框架完美契合您的项目需求，将让Voice Agent + Computer Tool的结合更加强大和易用！